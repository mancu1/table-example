# Объяснение сегментов в AxisIndex

## Что такое сегменты?

**Сегмент** - это непрерывный диапазон позиций с их стабильными ID.

```typescript
interface Segment {
  startPos: number;  // Начальная позиция (1-based)
  ids: AxisId[];     // Массив стабильных ID
}
```

## Зачем нужны сегменты?

### Проблема
При создании таблицы 100×26 нам нужно:
1. Позиции 1...100 для строк (что видит пользователь)
2. Стабильные ID для каждой позиции (что хранится внутри)

### Решение
Вместо того чтобы хранить отдельную Map `позиция → ID`, мы храним массив сегментов.

## Пример: инициализация

```typescript
// При создании таблицы 100×26
const rows = new AxisIndex(100);
```

Создается **1 сегмент**:
```json
{
  "startPos": 1,
  "count": 100,
  "ids": ["id0", "id1", "id2", ..., "id99"]
}
```

Позиция 1 → `id0`  
Позиция 2 → `id1`  
...  
Позиция 100 → `id99`

**Статистика:** `100 / 1` (100 ID в 1 сегменте)

## Пример: вставка строк

### Исходное состояние
```
Позиции: 1  2  3  4  5
ID:      id0 id1 id2 id3 id4

Сегменты: [
  { startPos: 1, ids: [id0, id1, id2, id3, id4] }
]
```

### Вставляем 2 строки на позицию 3
```typescript
rows.insert(3, 2);
// Создаются новые ID: id5, id6
```

### Результат
```
Позиции: 1  2  3   4   5  6  7
ID:      id0 id1 id5 id6 id2 id3 id4

Сегменты: [
  { startPos: 1, ids: [id0, id1, id5, id6, id2, id3, id4] }
]
```

Всё ещё **1 сегмент**, но теперь с 7 ID.

**Статистика:** `7 / 1`

## Почему изначально всегда 1 сегмент?

Потому что при инициализации мы создаем **непрерывный** массив ID:

```typescript
constructor(initialCount: number = 100) {
  const ids: AxisId[] = [];
  for (let i = 0; i < initialCount; i++) {
    ids.push(this.generateId());
  }
  this.segments.push({ startPos: 1, ids }); // ОДИН сегмент
}
```

## Когда появляются несколько сегментов?

В текущей реализации - **практически никогда**, потому что при вставке мы просто добавляем ID в существующий массив:

```typescript
insert(atPos: number, count: number): AxisId[] {
  const newIds = [...]; // Генерируем новые ID
  
  // Находим сегмент и вставляем в него
  seg.ids.splice(offset, 0, ...newIds);
  
  // Всё ещё 1 сегмент!
}
```

### Потенциально несколько сегментов могли бы появиться если:
1. Реализовать оптимизацию для разреженных вставок
2. Хранить отдельные сегменты для разных "областей" таблицы
3. Использовать более сложную структуру данных (B-дерево)

## Оптимизация сложности

### Текущая реализация
- **posToId(pos)**: O(S) где S - количество сегментов
- **idToPos(id)**: O(S × N) где N - средний размер сегмента
- В нашем случае S=1, поэтому:
  - **posToId**: O(1) - просто индекс в массиве
  - **idToPos**: O(N) - линейный поиск по массиву

### Почему это важно знать?
Когда в статистике показано `100 / 1`:
- **100** - это общее количество ID (размер массива)
- **1** - это количество сегментов (итераций для поиска)

Если бы было `100 / 10`, это означало бы:
- 100 ID распределены по 10 сегментам
- В среднем ~10 ID на сегмент
- Поиск требует до 10 итераций по сегментам

## Визуализация в панели отладки

### Пустая таблица
```json
{
  "rows": [
    {
      "startPos": 1,
      "count": 100,
      "ids": ["id0", "id1", "id2", "id3", "id4", "..."]
    }
  ]
}
```
Читаем: "С позиции 1 начинается сегмент из 100 ID"

### После многих операций (теоретически)
```json
{
  "rows": [
    {
      "startPos": 1,
      "count": 50,
      "ids": ["id0", "id1", "..."]
    },
    {
      "startPos": 51,
      "count": 30,
      "ids": ["id200", "id201", "..."]
    },
    {
      "startPos": 81,
      "count": 20,
      "ids": ["id400", "id401", "..."]
    }
  ]
}
```
Читаем: "3 сегмента: позиции 1-50, 51-80, 81-100"

## Итого

✅ **Правильно:** Смотреть на `totalIds()` для понимания размера  
✅ **Правильно:** Смотреть на `segmentCount()` для понимания структуры  
❌ **Неправильно:** Путать количество сегментов с количеством ID

**В нашей реализации:** почти всегда будет 1 сегмент, но с растущим количеством ID при вставках.

## Улучшение для будущего

Для действительно больших таблиц с частыми вставками можно:
1. Разбивать слишком большие сегменты (> 1000 ID)
2. Использовать сбалансированное дерево вместо массива сегментов
3. Кешировать обратный индекс `id → позиция`

Но для текущего MVP простой массив в одном сегменте работает отлично!

